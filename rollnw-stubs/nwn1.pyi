from . import Area as Area, AttackData as AttackData, Creature as Creature, DamageCategory as DamageCategory, DiceRoll as DiceRoll, Door as Door, Effect as Effect, Encounter as Encounter, Item as Item, ItemProperty as ItemProperty, ObjectBase as ObjectBase, ObjectHandle as ObjectHandle, ObjectType as ObjectType, Placeable as Placeable, Store as Store, Trigger as Trigger, Waypoint as Waypoint

def create_object(resref: str, type: ObjectType) -> ObjectBase: ...
def destroy_object(obj: ObjectBase) -> None: ...
def apply_effect(obj: ObjectBase, effect: Effect) -> bool: ...
def has_effect_applied(obj: ObjectBase, type: int, subtype: int = -1) -> bool: ...
def remove_effect(obj: ObjectBase, effect: Effect, destroy: bool = True) -> bool: ...
def remove_effects_by(obj: ObjectBase, creator: ObjectHandle) -> int: ...
def count_feats_in_range(obj: Creature, start: int, end: int) -> int: ...
def get_all_available_feats(obj: Creature) -> list[int]: ...
def has_feat_successor(obj: Creature, feat: int) -> tuple[int, int]: ...
def highest_feat_in_range(obj: Creature, start: int, end: int) -> int: ...
def knows_feat(obj: Creature, feat: int) -> bool: ...
def item_has_property(item: Item, type: int, subtype: int = -1) -> bool: ...
def itemprop_to_string(ip: ItemProperty) -> str: ...
def get_current_hitpoints(obj: ObjectBase) -> int: ...
def get_max_hitpoints(obj: ObjectBase) -> int: ...
def saving_throw(obj: ObjectBase, type: int, type_vs: int = -1, versus: ObjectBase = None) -> int: ...
def resolve_saving_throw(obj: ObjectBase, type: int, dc: int, type_vs: int = -1, versus: ObjectBase = None) -> bool: ...
def get_ability_score(obj: Creature, ability, base: bool = False) -> int: ...
def get_ability_modifier(obj: Creature, ability, base: bool = False) -> int: ...
def get_dex_modifier(obj: Creature) -> int: ...
def calculate_ac_versus(obj: ObjectBase, versus: ObjectBase | None = None, is_touch_attack: bool = False) -> int: ...
def calculate_item_ac(obj: Item) -> int: ...
def add_known_spell(obj: Creature, class_: int, spell: int) -> bool: ...
def add_memorized_spell(obj: Creature, class_: int, spell: int, meta: int = 0) -> bool: ...
def compute_total_spell_slots(obj: Creature, class_: int, spell_level: int) -> int: ...
def compute_total_spells_knowable(obj: Creature, class_: int, spell_level: int) -> int: ...
def get_available_spell_slots(obj: Creature, class_: int, spell_level: int) -> int: ...
def get_available_spell_uses(obj: Creature, class_: int, spell: int, min_spell_level: int = 0, meta: int = 0) -> int: ...
def get_caster_level(obj: Creature, class_: int) -> int: ...
def get_knows_spell(obj: Creature, class_: int, spell: int) -> bool: ...
def get_spell_dc(obj: Creature, class_: int, spell: int) -> int: ...
def recompute_all_availabe_spell_slots(obj: Creature) -> None: ...
def remove_known_spell(obj: Creature, class_: int, spell: int) -> None: ...
def can_use_monk_abilities(obj: Creature) -> tuple[bool, int]: ...
def attacks_per_second(obj: Creature, type, versus: ObjectBase) -> float: ...
def base_attack_bonus(obj: Creature) -> int: ...
def calculate_challenge_rating(obj: Creature) -> float: ...
def equip_index_to_attack_type(equip) -> None: ...
def get_weapon_by_attack_type(obj: Creature, type) -> Item: ...
def is_flanked(target: Creature, attacker: Creature) -> bool: ...
def resolve_attack(obj: Creature, type, versus: ObjectBase): ...
def resolve_attack_bonus(obj: Creature, type, versus: ObjectBase | None = None) -> int: ...
def resolve_attack_damage(obj: Creature, versus: ObjectBase, data: AttackData) -> int: ...
def resolve_concealment(obj: ObjectBase, type, target: ObjectBase, vs_ranged: bool) -> tuple[int, bool]: ...
def resolve_critical_multiplier(obj: Creature, type, versus: ObjectBase | None = None) -> int: ...
def resolve_critical_threat(obj: Creature, type) -> int: ...
def resolve_damage_modifiers(obj: Creature, versus: ObjectBase, data: AttackData) -> None: ...
def resolve_damage_immunity(obj: ObjectBase, dmg_type, versus: ObjectBase | None = None) -> int: ...
def resolve_damage_reduction(obj: ObjectBase, power: int, versus: ObjectBase | None = None) -> tuple[int, Effect]: ...
def resolve_damage_resistance(obj: ObjectBase, dmg_type, versus: ObjectBase | None = None) -> tuple[int, Effect]: ...
def resolve_dual_wield_penalty(obj: Creature) -> tuple[int, int]: ...
def resolve_iteration_penalty(obj: Creature, attack_type): ...
def resolve_number_of_attacks(obj: Creature, offhand: bool = False) -> tuple[int, int]: ...
def resolve_target_state(obj: Creature, versus: ObjectBase): ...
def resolve_unarmed_damage(obj: Creature) -> DiceRoll: ...
def resolve_weapon_damage(obj: Creature, weapon: Item) -> DiceRoll: ...
def resolve_weapon_power(obj: Creature, weapon: Item) -> int: ...
def weapon_is_finessable(obj: Creature, weapon: Item) -> bool: ...
def weapon_iteration(obj: Creature, weapon: Item) -> int: ...
def can_equip_item(obj: Creature, item: Item, slot: int) -> bool: ...
def equip_item(obj: Creature, item: Item, slot: int) -> bool: ...
def get_equipped_item(obj: Creature, slot) -> Item: ...
def unequip_item(obj: Creature, slot: int) -> Item: ...
def get_skill_rank(obj: Creature, skill: int, versus: ObjectBase = None, base: bool = False): ...
def resolve_skill_check(obj: Creature, skill: int, dc: int, versus: ObjectBase = None) -> bool: ...
def add_special_ability(obj: Creature, ability: int, level: int = 0) -> None: ...
def clear_special_ability(obj: Creature, ability: int) -> None: ...
def get_has_special_ability(obj: Creature, ability: int) -> bool: ...
def get_special_ability_level(obj: Creature, ability: int) -> int: ...
def get_special_ability_uses(obj: Creature, ability: int) -> int: ...
def set_special_ability_level(obj: Creature, ability: int, level: int) -> None: ...
def set_special_ability_uses(obj: Creature, ability: int, uses: int, level: int = 0) -> None: ...
def remove_special_ability(obj: Creature, ability: int) -> None: ...
def calculate_item_value(item: Item) -> float: ...
def effect_ability_modifier(ability: int, modifier: int) -> Effect: ...
def effect_armor_class_modifier(type: int, modifier: int) -> Effect: ...
def effect_attack_modifier(attack: int, modifier: int) -> Effect: ...
def effect_bonus_spell_slot(class_: int, spell_level: int) -> Effect: ...
def effect_concealment(value: int, type: int = 0) -> Effect: ...
def effect_damage_bonus(type: int, dice: DiceRoll, cat: DamageCategory = ...) -> Effect: ...
def effect_damage_immunity(type: int, value: int) -> Effect: ...
def effect_damage_penalty(type: int, dice: DiceRoll) -> Effect: ...
def effect_damage_reduction(value: int, power: int, max: int = 0) -> Effect: ...
def effect_damage_resistance(type: int, value: int, max: int = 0) -> Effect: ...
def effect_haste() -> Effect: ...
def effect_hitpoints_temporary(amount: int) -> Effect: ...
def effect_miss_chance(value: int, type: int = 0) -> Effect: ...
def effect_save_modifier(save: int, modifier: int, vs: int = -1) -> Effect: ...
def effect_skill_modifier(skill: int, modifier: int) -> Effect: ...
def itemprop_ability_modifier(ability, modifier) -> ItemProperty: ...
def itemprop_armor_class_modifier(value) -> ItemProperty: ...
def itemprop_attack_modifier(value) -> ItemProperty: ...
def itemprop_bonus_spell_slot(class_: int, spell_level: int) -> ItemProperty: ...
def itemprop_damage_bonus(type: int, value: int) -> ItemProperty: ...
def itemprop_enhancement_modifier(value: int) -> ItemProperty: ...
def itemprop_haste() -> ItemProperty: ...
def itemprop_keen() -> ItemProperty: ...
def itemprop_save_modifier(type: int, modifier: int) -> ItemProperty: ...
def itemprop_save_vs_modifier(type: int, modifier: int) -> ItemProperty: ...
def itemprop_skill_modifier(skill, modifier) -> ItemProperty: ...
